{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AeroGameFramework \u00b6 About \u00b6 AeroGameFramework is a Roblox game framework that makes development easy and fun. The framework is designed to simplify the communication between modules and seamlessly bridge the gap between the server and client. Never again will you have to touch RemoteFunctions or RemoteEvents. Collaborate \u00b6 AeroGameFramework is an open-source project, and your support is much appreciated. Feel free to report bugs, suggest features, and make pull requests. Please visit the GitHub repository for more information. The framework was built and is supported primary by Stephen Leitnick . Example \u00b6 Here is an example of a client-side controller invoking a server-side service to respawn the player. Notice that no remote objects have to be explicitly referenced: 1 2 3 4 5 6 7 8 9 10 11 -- Client: local MyController = {} function MyController : Start () local didRespawn = self . Services . MyService : Respawn () if ( didRespawn ) then ... end end return MyController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- Server: local MyService = { Client = {}} function MyService . Client : Respawn ( player ) local humanoid = player . Character and player . Character : FindFirstChild ( \"Humanoid\" ) -- Only allow respawning if the player is dead: if (( not humanoid ) or humanoid . Health == 0 ) then player : LoadCharacter () return true end return false end return MyService These are complete code examples. They could be put into the framework and work as-is.","title":"Home"},{"location":"#aerogameframework","text":"","title":"AeroGameFramework"},{"location":"#about","text":"AeroGameFramework is a Roblox game framework that makes development easy and fun. The framework is designed to simplify the communication between modules and seamlessly bridge the gap between the server and client. Never again will you have to touch RemoteFunctions or RemoteEvents.","title":"About"},{"location":"#collaborate","text":"AeroGameFramework is an open-source project, and your support is much appreciated. Feel free to report bugs, suggest features, and make pull requests. Please visit the GitHub repository for more information. The framework was built and is supported primary by Stephen Leitnick .","title":"Collaborate"},{"location":"#example","text":"Here is an example of a client-side controller invoking a server-side service to respawn the player. Notice that no remote objects have to be explicitly referenced: 1 2 3 4 5 6 7 8 9 10 11 -- Client: local MyController = {} function MyController : Start () local didRespawn = self . Services . MyService : Respawn () if ( didRespawn ) then ... end end return MyController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- Server: local MyService = { Client = {}} function MyService . Client : Respawn ( player ) local humanoid = player . Character and player . Character : FindFirstChild ( \"Humanoid\" ) -- Only allow respawning if the player is dead: if (( not humanoid ) or humanoid . Health == 0 ) then player : LoadCharacter () return true end return false end return MyService These are complete code examples. They could be put into the framework and work as-is.","title":"Example"},{"location":"controllers/","text":"Controllers \u00b6 A service is a singleton initiated at runtime on the server. Services should serve specific purposes. For instance, the provided DataService allows simplified data management. You might also create a WeaponService, which might be used for holding and figuring out weapon information for the players. A controller is a singleton initiated at runtime on the client. Controllers should serve a specific purpose. For instance, the provided Fade controller allows for control of simple screen fading. Controllers often interact with server-side services as well. Another example of a controller could be a Camera controller, which has the task of specifically controlling the player's camera. API \u00b6 A controller in its simplest form looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local MyController = {} function MyController : Start () -- Called after all controllers have been initialized -- Called asynchronously from other controllers -- Safe to call any other framework modules end function MyController : Init () -- Called after all modules have been \"required\" but before 'Start()' has been called on any of them -- Safe to reference 'self.Services/Controllers/Modules/Shared' -- NOT safe to USE/CALL other services yet (use them in/after Start method) -- Register all events here (but only connect to events in Start) end return MyController Injected Properties \u00b6 Property Description controller.Controllers Table of all other controllers, referenced by the name of the ModuleScript controller.Modules Table of all modules, referenced by the name of the ModuleScript controller.Shared Table of all shared modules, referenced by the name of the ModuleScript controller.Services Table of all server-side services, referenced by the name of the ModuleScript controller.Player Reference to the LocalPlayer ( game.Players.LocalPlayer ) Injected Methods \u00b6 Returns Method void controller:WrapModule(Table tbl) void controller:RegisterEvent(String eventName) void controller:FireEvent(String eventName, ...) void controller:ConnectEvent(String eventName, Function handler) controller:Init() \u00b6 The Init method is called on each controller in the framework in a synchronous and linear progression. In other words, each controller's Init method is invoked one after the other. Each Init method must fully execute before moving onto the next. This is essentially the constructor for the controller singleton. The method should be used to set up your controller. For instance, you might want to create events or reference other controllers. Use the Init method to register events and initialize any necessary components before the Start method is invoked. Warning The Init method should not invoke any methods from other controllers yet, because it is not guaranteed that those controllers have had their Init methods invoked yet. It is safe to reference other controllers, but not to invoke their methods. controller:Start() \u00b6 The Start method is called after all controllers have been initialized (i.e. their Init methods have been fully executed). Each Start method is executed on a separate thread (asynchronously). From here, it is safe to reference and invoke other controllers in the framework. Custom Methods \u00b6 Adding your own methods to a controller is very easy. Simply attach a function to the controller table: 1 2 3 4 5 6 7 8 9 -- Custom method: function MyController : PrintSomething (...) print ( \"MyController:\" , ...) end function MyController : Start () -- Invoke the custom method: self : PrintSomething ( \"Hi\" , \"Hello\" , 32 , true , \"ABC\" ) end Other controllers can also invoke your custom method: 1 2 3 function AnotherController : Start () self . Services . MyService : PrintSomething ( \"Hello\" , false , 64 ) end Events \u00b6 You can create and listen to events using the RegisterEvent , ConnectEvent , and FireEvent methods. All events should always be registered within the Init method. The ConnectEvent and FireEvent methods should never be used within an Init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyController : Start () -- Connect to 'Hello' event: self : ConnectEvent ( \"Hello\" , function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self : FireEvent ( \"Hello\" , \"Hello world!\" ) end function MyController : Init () -- Register 'Hello' event: self : RegisterEvent ( \"Hello\" ) end Alternatively, the Event object is available under Shared: 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyController : Start () -- Connect to 'Hello' event: self . Hello : Connect ( function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self . Hello : Fire ( \"Hello world!\" ) end function MyController : Init () -- Create 'Hello' event: self . Hello = self . Shared . Event . new () end WrapModule \u00b6 The WrapModule method can be used to transform a table into a framework-like module. In other words, it sets the table's metatable to the same metatable used by other framework modules, thus exposing the framework to the given table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function MyController : Start () local thisThing = {} function thisThing : Start () print ( \"thisThing started\" ) end function thisThing : Init () print ( \"thisThing initialized\" ) end -- Transform 'thisThing' into a framework object: self : WrapModule ( thisThing ) -- Another example where an external module is loaded: local anotherThing = require ( someModule ) self : WrapModule ( anotherThing ) end Tip This can be useful if you are requiring other non-framework modules in which you want to expose the framework. Other Examples \u00b6 Invoking another controller \u00b6 1 2 3 4 5 6 7 function MyController : Start () local fade = self . Controllers . Fade fade : SetText ( \"Fade Example\" ) fade : Out () wait ( 1 ) fade : In () end Invoking a service \u00b6 1 2 3 4 5 6 function MyController : Start () -- Get pints: local pointsService = self . Services . PointsService local points = pointsService : GetPoints () print ( \"Points:\" , points ) end Using a module \u00b6 1 2 3 4 function MyController : Start () local someModule = self . Modules . SomeModule someModule : DoSomething () end Using a shared module \u00b6 1 2 3 4 5 6 function MyController : Start () -- Print the current date: local Date = self . Shared . Date local now = Date . new () print ( \"Now\" , now ) end Connecting to a service event \u00b6 1 2 3 4 5 6 function MyController : Start () local dataService = self . Services . DataService dataService . Failed : Connect ( function ( method , key , errorMessage ) warn ( \"DataService failed:\" , method , key , errorMessage ) end ) end Firing a service event \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Client controller: function MyController : Start () self . Services . CustomService . Hello : Fire ( \"Hello from the client\" ) end --------------------------------------------------------------------- -- Server service: function CustomService : Start () self . Services : ConnectClientEvent ( \"Hello\" , function ( player , msg ) print ( player . Name .. \" says: \" .. msg ) end ) end function CustomService : Init () self : RegisterClientEvent ( \"Hello\" ) end No Server-to-Client Methods \u00b6 As you may have noticed, there is no way to create a method on a controller that a server-side service can invoke. This is by design. There are a lot of dangers in allowing the server to invoke client-side methods, and thus the framework simply does not supply a way of doing so. Internally, this would be allowed via remoteFunction:InvokeClient(...) . If the server needs information from a client, a client controller should fire a service event. For more information, please read the \"Note\" and \"Warning\" section under the RemoteFunction:InvokeClient() documentation page and this YouTube video discussing the issue in more detail.","title":"Controllers"},{"location":"controllers/#controllers","text":"A service is a singleton initiated at runtime on the server. Services should serve specific purposes. For instance, the provided DataService allows simplified data management. You might also create a WeaponService, which might be used for holding and figuring out weapon information for the players. A controller is a singleton initiated at runtime on the client. Controllers should serve a specific purpose. For instance, the provided Fade controller allows for control of simple screen fading. Controllers often interact with server-side services as well. Another example of a controller could be a Camera controller, which has the task of specifically controlling the player's camera.","title":"Controllers"},{"location":"controllers/#api","text":"A controller in its simplest form looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local MyController = {} function MyController : Start () -- Called after all controllers have been initialized -- Called asynchronously from other controllers -- Safe to call any other framework modules end function MyController : Init () -- Called after all modules have been \"required\" but before 'Start()' has been called on any of them -- Safe to reference 'self.Services/Controllers/Modules/Shared' -- NOT safe to USE/CALL other services yet (use them in/after Start method) -- Register all events here (but only connect to events in Start) end return MyController","title":"API"},{"location":"controllers/#injected-properties","text":"Property Description controller.Controllers Table of all other controllers, referenced by the name of the ModuleScript controller.Modules Table of all modules, referenced by the name of the ModuleScript controller.Shared Table of all shared modules, referenced by the name of the ModuleScript controller.Services Table of all server-side services, referenced by the name of the ModuleScript controller.Player Reference to the LocalPlayer ( game.Players.LocalPlayer )","title":"Injected Properties"},{"location":"controllers/#injected-methods","text":"Returns Method void controller:WrapModule(Table tbl) void controller:RegisterEvent(String eventName) void controller:FireEvent(String eventName, ...) void controller:ConnectEvent(String eventName, Function handler)","title":"Injected Methods"},{"location":"controllers/#controllerinit","text":"The Init method is called on each controller in the framework in a synchronous and linear progression. In other words, each controller's Init method is invoked one after the other. Each Init method must fully execute before moving onto the next. This is essentially the constructor for the controller singleton. The method should be used to set up your controller. For instance, you might want to create events or reference other controllers. Use the Init method to register events and initialize any necessary components before the Start method is invoked. Warning The Init method should not invoke any methods from other controllers yet, because it is not guaranteed that those controllers have had their Init methods invoked yet. It is safe to reference other controllers, but not to invoke their methods.","title":"controller:Init()"},{"location":"controllers/#controllerstart","text":"The Start method is called after all controllers have been initialized (i.e. their Init methods have been fully executed). Each Start method is executed on a separate thread (asynchronously). From here, it is safe to reference and invoke other controllers in the framework.","title":"controller:Start()"},{"location":"controllers/#custom-methods","text":"Adding your own methods to a controller is very easy. Simply attach a function to the controller table: 1 2 3 4 5 6 7 8 9 -- Custom method: function MyController : PrintSomething (...) print ( \"MyController:\" , ...) end function MyController : Start () -- Invoke the custom method: self : PrintSomething ( \"Hi\" , \"Hello\" , 32 , true , \"ABC\" ) end Other controllers can also invoke your custom method: 1 2 3 function AnotherController : Start () self . Services . MyService : PrintSomething ( \"Hello\" , false , 64 ) end","title":"Custom Methods"},{"location":"controllers/#events","text":"You can create and listen to events using the RegisterEvent , ConnectEvent , and FireEvent methods. All events should always be registered within the Init method. The ConnectEvent and FireEvent methods should never be used within an Init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyController : Start () -- Connect to 'Hello' event: self : ConnectEvent ( \"Hello\" , function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self : FireEvent ( \"Hello\" , \"Hello world!\" ) end function MyController : Init () -- Register 'Hello' event: self : RegisterEvent ( \"Hello\" ) end Alternatively, the Event object is available under Shared: 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyController : Start () -- Connect to 'Hello' event: self . Hello : Connect ( function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self . Hello : Fire ( \"Hello world!\" ) end function MyController : Init () -- Create 'Hello' event: self . Hello = self . Shared . Event . new () end","title":"Events"},{"location":"controllers/#wrapmodule","text":"The WrapModule method can be used to transform a table into a framework-like module. In other words, it sets the table's metatable to the same metatable used by other framework modules, thus exposing the framework to the given table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function MyController : Start () local thisThing = {} function thisThing : Start () print ( \"thisThing started\" ) end function thisThing : Init () print ( \"thisThing initialized\" ) end -- Transform 'thisThing' into a framework object: self : WrapModule ( thisThing ) -- Another example where an external module is loaded: local anotherThing = require ( someModule ) self : WrapModule ( anotherThing ) end Tip This can be useful if you are requiring other non-framework modules in which you want to expose the framework.","title":"WrapModule"},{"location":"controllers/#other-examples","text":"","title":"Other Examples"},{"location":"controllers/#invoking-another-controller","text":"1 2 3 4 5 6 7 function MyController : Start () local fade = self . Controllers . Fade fade : SetText ( \"Fade Example\" ) fade : Out () wait ( 1 ) fade : In () end","title":"Invoking another controller"},{"location":"controllers/#invoking-a-service","text":"1 2 3 4 5 6 function MyController : Start () -- Get pints: local pointsService = self . Services . PointsService local points = pointsService : GetPoints () print ( \"Points:\" , points ) end","title":"Invoking a service"},{"location":"controllers/#using-a-module","text":"1 2 3 4 function MyController : Start () local someModule = self . Modules . SomeModule someModule : DoSomething () end","title":"Using a module"},{"location":"controllers/#using-a-shared-module","text":"1 2 3 4 5 6 function MyController : Start () -- Print the current date: local Date = self . Shared . Date local now = Date . new () print ( \"Now\" , now ) end","title":"Using a shared module"},{"location":"controllers/#connecting-to-a-service-event","text":"1 2 3 4 5 6 function MyController : Start () local dataService = self . Services . DataService dataService . Failed : Connect ( function ( method , key , errorMessage ) warn ( \"DataService failed:\" , method , key , errorMessage ) end ) end","title":"Connecting to a service event"},{"location":"controllers/#firing-a-service-event","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Client controller: function MyController : Start () self . Services . CustomService . Hello : Fire ( \"Hello from the client\" ) end --------------------------------------------------------------------- -- Server service: function CustomService : Start () self . Services : ConnectClientEvent ( \"Hello\" , function ( player , msg ) print ( player . Name .. \" says: \" .. msg ) end ) end function CustomService : Init () self : RegisterClientEvent ( \"Hello\" ) end","title":"Firing a service event"},{"location":"controllers/#no-server-to-client-methods","text":"As you may have noticed, there is no way to create a method on a controller that a server-side service can invoke. This is by design. There are a lot of dangers in allowing the server to invoke client-side methods, and thus the framework simply does not supply a way of doing so. Internally, this would be allowed via remoteFunction:InvokeClient(...) . If the server needs information from a client, a client controller should fire a service event. For more information, please read the \"Note\" and \"Warning\" section under the RemoteFunction:InvokeClient() documentation page and this YouTube video discussing the issue in more detail.","title":"No Server-to-Client Methods"},{"location":"execution_model/","text":"Execution Model \u00b6 Services and Controllers \u00b6 Services and Controllers act as singletons. In other words, only one instance exists per service or controller in a given environment. All modules are loaded using require() at the start of runtime. All modules have properties and methods exposed via metamethods. Each Init method on the modules are invoked one-by-one synchronously. Each Start method on the modules are invoked asynchronously. The module remains in memory for the remainder of runtime. Modules and Shared \u00b6 A module (in Modules or Shared) is loaded using require() the first time it is referenced (e.g. lazy-loaded). The module has properties and methods exposed via metatable (using WrapTable ) The module's Init method is invoked synchronously. The module's Start method is invoked immediately and asynchronously after the Init method is completed. Preventing Init or Start \u00b6 There might be times where it is not desired for the framework to invoke either the Start or the Init method on a module, service, or controller. In such an instance, a flag can be added to indicate that the method should not be invoked by the framework. The two flags are: __aeroPreventInit __aeroPreventStart Note Set the flag to a truthy value (preferrably just true ). See the example under the Modules page. Notes and Best Practices \u00b6 The Init and Start methods are always optional, but it is good practice to always include them. The Init method should be used to set up the individual module and register events. The Init method should try to do as minimal work as possible, as other modules are blocked until it is completed. The Init method should not be used to invoke methods from other modules in the framework (that should be done in or after Start ) Events must be registered in the Init method. Events should never be connected or fired within the Init method. Do this within the Start method. Because Modules and Shared modules are lazy-loaded, their Init methods are invoked the first time they are referenced.","title":"Execution Model"},{"location":"execution_model/#execution-model","text":"","title":"Execution Model"},{"location":"execution_model/#services-and-controllers","text":"Services and Controllers act as singletons. In other words, only one instance exists per service or controller in a given environment. All modules are loaded using require() at the start of runtime. All modules have properties and methods exposed via metamethods. Each Init method on the modules are invoked one-by-one synchronously. Each Start method on the modules are invoked asynchronously. The module remains in memory for the remainder of runtime.","title":"Services and Controllers"},{"location":"execution_model/#modules-and-shared","text":"A module (in Modules or Shared) is loaded using require() the first time it is referenced (e.g. lazy-loaded). The module has properties and methods exposed via metatable (using WrapTable ) The module's Init method is invoked synchronously. The module's Start method is invoked immediately and asynchronously after the Init method is completed.","title":"Modules and Shared"},{"location":"execution_model/#preventing-init-or-start","text":"There might be times where it is not desired for the framework to invoke either the Start or the Init method on a module, service, or controller. In such an instance, a flag can be added to indicate that the method should not be invoked by the framework. The two flags are: __aeroPreventInit __aeroPreventStart Note Set the flag to a truthy value (preferrably just true ). See the example under the Modules page.","title":"Preventing Init or Start"},{"location":"execution_model/#notes-and-best-practices","text":"The Init and Start methods are always optional, but it is good practice to always include them. The Init method should be used to set up the individual module and register events. The Init method should try to do as minimal work as possible, as other modules are blocked until it is completed. The Init method should not be used to invoke methods from other modules in the framework (that should be done in or after Start ) Events must be registered in the Init method. Events should never be connected or fired within the Init method. Do this within the Start method. Because Modules and Shared modules are lazy-loaded, their Init methods are invoked the first time they are referenced.","title":"Notes and Best Practices"},{"location":"install/","text":"Install & Setup \u00b6 The preferred editor for the AeroGameFramework is Visual Studio Code . AeroGameFramework includes a VS Code extension, and ties in with other useful extensions & plugins (such as Rojo and Luacheck). Requirements \u00b6 Name Description Required AeroGameFramework Main VS Code extension Yes Rojo Sync files between VS Code and Roblox Studio Yes Rojo for VS Code Use and manage Rojo directly from VS Code No Luacheck Static analyzer and linter for Lua No (Yes if using vscode-lua) vscode-lua Intellisense and linting for Lua (utilizes Luacheck) No Project Setup \u00b6 Created a new directory for your project Open the directory within VS Code ( File > Open Folder... ) From the command panel ( Ctrl+Shift+P ), run AeroGameFramework: Init If using the Rojo VS Code extension, restart VS Code Enable HTTP requests within your Roblox game settings Start Rojo and run the Rojo plugin within Roblox Studio If not using the Rojo VS Code extension, run rojo serve Directory Structure \u00b6 src : Source files Client : Client-side code Controllers : Client-side singleton controllers Modules : Lazy-loaded plain modules Server : Server-side code Services : Server-side singleton services Modules : Lazy-loaded plain modules Shared : Lazy-loaded plain modules shared between the client and server _framework : Internal framework source files (Hidden within VS Code by default) Note The rojo.json and default.project.json files are specifically configured to work with the directory structure described above. Changing the structure may break Rojo from properly syncing changes into Roblox Studio. AGF Treeview \u00b6 The VS Code extension for AeroGameFramework provides a simplified directory hierarchy that will only show the source files that should be edited. In other words, it hides all of the files that you do not need to worry about. This view can be selected from the \"AGF\" icon on the left-hand panel in VS Code. Creating new source files (Services, Controllers, and Modules) \u00b6 Right-click wihtin the AGF Treeview and click on AeroGameFramework: Create from the context menu, or click the Script Add button at the top Select whether the source file should exist within the Server, Client, or Shared environment Select the source type (e.g. Service, Controller, or Module) Type in the name and press Enter Tip If you right-click within given directories, the extension will automatically assume the desired file type. For instance, if you right-click on Services and click Create, the extension will immediately prompt for a new service name. Tip If you right-click and click Create on an existing source file, you can create nested modules within the existing file. This will automatically create the necessary Rojo structure. Please note that nested modules do not get consumed by the framework and must be required manually. Note When creating a Module, a prompt will show up to choose between a Plain Module and a Class Module. A Plain Module is just a typical ModuleScript with an empty table defined. A Class Module contains the necessary boilerplate code for basic OOP modules. Roblox Structure \u00b6 AeroGameFramework is structured into three major categories: Server, Client, and Shared. Environment Location Description Server ServerStorage.Aero Server-side code Client StarterPlayerScripts.Aero Client-side code Shared ReplicatedStorage.Aero Shared modules between the server and client Note If developing within Visual Studio Code, these folders should be left untouched within Roblox Studio to prevent any unexpected data loss due to Rojo syncing.","title":"Install & Setup"},{"location":"install/#install-setup","text":"The preferred editor for the AeroGameFramework is Visual Studio Code . AeroGameFramework includes a VS Code extension, and ties in with other useful extensions & plugins (such as Rojo and Luacheck).","title":"Install &amp; Setup"},{"location":"install/#requirements","text":"Name Description Required AeroGameFramework Main VS Code extension Yes Rojo Sync files between VS Code and Roblox Studio Yes Rojo for VS Code Use and manage Rojo directly from VS Code No Luacheck Static analyzer and linter for Lua No (Yes if using vscode-lua) vscode-lua Intellisense and linting for Lua (utilizes Luacheck) No","title":"Requirements"},{"location":"install/#project-setup","text":"Created a new directory for your project Open the directory within VS Code ( File > Open Folder... ) From the command panel ( Ctrl+Shift+P ), run AeroGameFramework: Init If using the Rojo VS Code extension, restart VS Code Enable HTTP requests within your Roblox game settings Start Rojo and run the Rojo plugin within Roblox Studio If not using the Rojo VS Code extension, run rojo serve","title":"Project Setup"},{"location":"install/#directory-structure","text":"src : Source files Client : Client-side code Controllers : Client-side singleton controllers Modules : Lazy-loaded plain modules Server : Server-side code Services : Server-side singleton services Modules : Lazy-loaded plain modules Shared : Lazy-loaded plain modules shared between the client and server _framework : Internal framework source files (Hidden within VS Code by default) Note The rojo.json and default.project.json files are specifically configured to work with the directory structure described above. Changing the structure may break Rojo from properly syncing changes into Roblox Studio.","title":"Directory Structure"},{"location":"install/#agf-treeview","text":"The VS Code extension for AeroGameFramework provides a simplified directory hierarchy that will only show the source files that should be edited. In other words, it hides all of the files that you do not need to worry about. This view can be selected from the \"AGF\" icon on the left-hand panel in VS Code.","title":"AGF Treeview"},{"location":"install/#creating-new-source-files-services-controllers-and-modules","text":"Right-click wihtin the AGF Treeview and click on AeroGameFramework: Create from the context menu, or click the Script Add button at the top Select whether the source file should exist within the Server, Client, or Shared environment Select the source type (e.g. Service, Controller, or Module) Type in the name and press Enter Tip If you right-click within given directories, the extension will automatically assume the desired file type. For instance, if you right-click on Services and click Create, the extension will immediately prompt for a new service name. Tip If you right-click and click Create on an existing source file, you can create nested modules within the existing file. This will automatically create the necessary Rojo structure. Please note that nested modules do not get consumed by the framework and must be required manually. Note When creating a Module, a prompt will show up to choose between a Plain Module and a Class Module. A Plain Module is just a typical ModuleScript with an empty table defined. A Class Module contains the necessary boilerplate code for basic OOP modules.","title":"Creating new source files (Services, Controllers, and Modules)"},{"location":"install/#roblox-structure","text":"AeroGameFramework is structured into three major categories: Server, Client, and Shared. Environment Location Description Server ServerStorage.Aero Server-side code Client StarterPlayerScripts.Aero Client-side code Shared ReplicatedStorage.Aero Shared modules between the server and client Note If developing within Visual Studio Code, these folders should be left untouched within Roblox Studio to prevent any unexpected data loss due to Rojo syncing.","title":"Roblox Structure"},{"location":"modules/","text":"Modules \u00b6 This section covers the three environments where modules exist: Server , Client , and Shared . Modules behave in the same way in each location. Usage \u00b6 Like other framework objects, modules can also have Init and Start methods. However, these methods are optional. The biggest difference with Modules is that they are lazy-loaded. In other words, modules are not necessarily loaded at the beginning of runtime. Instead, they are loaded the first time they are referenced. What this means is that you can have a large collection of modules that you reuse within many projects, but are not necessarily eating up much memory. Lazy-loading is handled in the background, and it should not affect anything regarding the way you use a module. The most noticeable difference is that the Init and Start methods will not be invoked until the first time a module is referenced. Like any ModuleScript on Roblox, modules have the same structure: 1 2 3 4 5 local MyModule = {} -- 'MyModule:Start()' and 'MyModule:Init()' methods are optional. return MyModule Prevent Init or Start \u00b6 If you are trying to use a module that already has a Start or Init method that doesn't relate to the AeroGameFramework (e.g. a 3rd-party module not designed for the framework), then you can prevent the framework from invoking these methods. This is done by setting the __aeroPreventInit and __aeroPreventStart flags on the module. Note that those two flags are prefixed by two underscores, similar to Lua metamethods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local MyModule = {} -- Prevent the framework from invoking the 'Start' method: MyModule . __aeroPreventStart = true function MyModule : Start () -- Won't be invoked by the framework end function MyModule : Init () -- Still will be invoked by the framework end return MyModule","title":"Modules"},{"location":"modules/#modules","text":"This section covers the three environments where modules exist: Server , Client , and Shared . Modules behave in the same way in each location.","title":"Modules"},{"location":"modules/#usage","text":"Like other framework objects, modules can also have Init and Start methods. However, these methods are optional. The biggest difference with Modules is that they are lazy-loaded. In other words, modules are not necessarily loaded at the beginning of runtime. Instead, they are loaded the first time they are referenced. What this means is that you can have a large collection of modules that you reuse within many projects, but are not necessarily eating up much memory. Lazy-loading is handled in the background, and it should not affect anything regarding the way you use a module. The most noticeable difference is that the Init and Start methods will not be invoked until the first time a module is referenced. Like any ModuleScript on Roblox, modules have the same structure: 1 2 3 4 5 local MyModule = {} -- 'MyModule:Start()' and 'MyModule:Init()' methods are optional. return MyModule","title":"Usage"},{"location":"modules/#prevent-init-or-start","text":"If you are trying to use a module that already has a Start or Init method that doesn't relate to the AeroGameFramework (e.g. a 3rd-party module not designed for the framework), then you can prevent the framework from invoking these methods. This is done by setting the __aeroPreventInit and __aeroPreventStart flags on the module. Note that those two flags are prefixed by two underscores, similar to Lua metamethods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local MyModule = {} -- Prevent the framework from invoking the 'Start' method: MyModule . __aeroPreventStart = true function MyModule : Start () -- Won't be invoked by the framework end function MyModule : Init () -- Still will be invoked by the framework end return MyModule","title":"Prevent Init or Start"},{"location":"services/","text":"Services \u00b6 A service is a singleton initiated at runtime on the server. Services should serve specific purposes. For instance, the provided DataService allows simplified data management. You might also create a WeaponService, which might be used for holding and figuring out weapon information for the players. API \u00b6 A service in its simplest form looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local MyService = { Client = {}} function MyService : Start () -- Called after all services have been initialized -- Called asynchronously from other services -- Safe to call any other framework modules end function MyService : Init () -- Called after all modules have been \"required\" but before 'Start()' has been called on any of them -- Safe to reference 'self.Services/Modules/Shared' -- NOT safe to USE/CALL other services yet (use them in/after Start method) -- Register all events here (but only connect to events in Start) end return MyService Injected Properties \u00b6 Property Description service.Services Table of all other services, referenced by the name of the ModuleScript service.Modules Table of all modules, referenced by the name of the ModuleScript service.Shared Table of all shared modules, referenced by the name of the ModuleScript service.Client.Server Reference back to the service, so client-facing methods can invoke server-facing methods Injected Methods \u00b6 Returns Method void service:WrapModule(Table tbl) void service:RegisterEvent(String eventName) void service:RegisterClientEvent(String clientEventName) void service:FireEvent(String eventName, ...) void service:FireClientEvent(String clientEventName, Player player, ...) void service:FireAllClientsEvent(String clientEventName, ...) void service:FireAllClientsEventExcept(String clientEventName, Player player, ...) Connection service:ConnectEvent(String eventName, Function handler) Connection service:ConnectClientEvent(String clientEventName, Function handler) service:Init() \u00b6 The Init method is called on each service in the framework in a synchronous and linear progression. In other words, each service's Init method is invoked one after the other. Each Init method must fully execute before moving onto the next. This is essentially the constructor for the service singleton. The method should be used to set up your service. For instance, you might want to create events or reference other services. Use the Init method to register events and initialize any necessary components before the Start method is invoked. Warning The Init method should not invoke any methods from other services yet, because it is not guaranteed that those services have had their Init methods invoked yet. It is safe to reference other services, but not to invoke their methods. service:Start() \u00b6 The Start method is called after all services have been initialized (i.e. their Init methods have been fully executed). Each Start method is executed on a separate thread (asynchronously). From here, it is safe to reference and invoke other services in the framework. Custom Methods \u00b6 Adding your own methods to a service is very easy. Simply attach a function to the service table: 1 2 3 4 5 6 7 8 9 -- Custom method: function MyService : PrintSomething (...) print ( \"MyService:\" , ...) end function MyService : Start () -- Invoke the custom method: self : PrintSomething ( \"Hi\" , \"Hello\" , 32 , true , \"ABC\" ) end Other services can also invoke your custom method: 1 2 3 function AnotherService : Start () self . Services . MyService : PrintSomething ( \"Hello\" , false , 64 ) end Server Events \u00b6 You can create and listen to events using the RegisterEvent , ConnectEvent , and FireEvent methods. All events should always be registered within the Init method. The ConnectEvent and FireEvent methods should never be used within an Init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyService : Start () -- Connect to 'Hello' event: self : ConnectEvent ( \"Hello\" , function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self : FireEvent ( \"Hello\" , \"Hello world!\" ) end function MyService : Init () -- Register 'Hello' event: self : RegisterEvent ( \"Hello\" ) end WrapModule \u00b6 The WrapModule method can be used to transform a table into a framework-like module. In other words, it sets the table's metatable to the same metatable used by other framework modules, thus exposing the framework to the given table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function MyService : Start () local thisThing = {} function thisThing : Start () print ( \"thisThing started\" ) end function thisThing : Init () print ( \"thisThing initialized\" ) end -- Transform 'thisThing' into a framework object: self : WrapModule ( thisThing ) end This can be useful if you are requiring other non-framework modules in which you want to expose the framework. Client Table \u00b6 The Client table is used to expose methods and events to the client. Client Methods \u00b6 To expose a method to the client, write a function attached to the client table: 1 2 3 function MyService . Client : Echo ( player , message ) return message end Attention The player argument must always be the first argument for client methods. Any other arguments reflect what the client has sent. Client Events \u00b6 To expose an event to the client, use the RegisterClientEvent method in the Init method. Use FireClientEvent and FireAllClientsEvent to fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 function MyService : Start () -- Fire client event for a specific player: self : FireClientEvent ( \"MyClientEvent\" , somePlayer , \"Hello\" ) -- Fire client event for all players: self : FireAllClientsEvent ( \"MyClientEvent\" , \"Hello\" ) end function MyService : Init () -- Register client event: self : RegisterClientEvent ( \"MyClientMethod\" ) end Reference Server Table \u00b6 When executing code with a client-exposed method, it is useful to be able to reference back to the main service table. Therefore, the Server property has been injected into the Client table: 1 2 3 4 5 6 7 8 9 -- Client-exposed 'Echo' method invoking 'Print' method: function MyService . Client : Echo ( player , message ) self . Server : Print ( message ) -- Note the reference to 'self.Server' return message end function MyService : Print ( msg ) return msg end Other Examples \u00b6 Invoking another service \u00b6 1 2 3 4 5 function MyService : Start () -- Get some global data from the DataService: local dataService = self . Services . DataService local data = dataService : GetGlobal ( \"Test\" ) end Using a Module \u00b6 1 2 3 4 function MyService : Start () local someModule = self . Modules . SomeModule someModule : DoSomething () end Using a Shared module \u00b6 1 2 3 4 5 6 function MyService : Start () -- Print the current date: local Date = self . Shared . Date local now = Date . new () print ( \"Now\" , now ) end","title":"Services"},{"location":"services/#services","text":"A service is a singleton initiated at runtime on the server. Services should serve specific purposes. For instance, the provided DataService allows simplified data management. You might also create a WeaponService, which might be used for holding and figuring out weapon information for the players.","title":"Services"},{"location":"services/#api","text":"A service in its simplest form looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local MyService = { Client = {}} function MyService : Start () -- Called after all services have been initialized -- Called asynchronously from other services -- Safe to call any other framework modules end function MyService : Init () -- Called after all modules have been \"required\" but before 'Start()' has been called on any of them -- Safe to reference 'self.Services/Modules/Shared' -- NOT safe to USE/CALL other services yet (use them in/after Start method) -- Register all events here (but only connect to events in Start) end return MyService","title":"API"},{"location":"services/#injected-properties","text":"Property Description service.Services Table of all other services, referenced by the name of the ModuleScript service.Modules Table of all modules, referenced by the name of the ModuleScript service.Shared Table of all shared modules, referenced by the name of the ModuleScript service.Client.Server Reference back to the service, so client-facing methods can invoke server-facing methods","title":"Injected Properties"},{"location":"services/#injected-methods","text":"Returns Method void service:WrapModule(Table tbl) void service:RegisterEvent(String eventName) void service:RegisterClientEvent(String clientEventName) void service:FireEvent(String eventName, ...) void service:FireClientEvent(String clientEventName, Player player, ...) void service:FireAllClientsEvent(String clientEventName, ...) void service:FireAllClientsEventExcept(String clientEventName, Player player, ...) Connection service:ConnectEvent(String eventName, Function handler) Connection service:ConnectClientEvent(String clientEventName, Function handler)","title":"Injected Methods"},{"location":"services/#serviceinit","text":"The Init method is called on each service in the framework in a synchronous and linear progression. In other words, each service's Init method is invoked one after the other. Each Init method must fully execute before moving onto the next. This is essentially the constructor for the service singleton. The method should be used to set up your service. For instance, you might want to create events or reference other services. Use the Init method to register events and initialize any necessary components before the Start method is invoked. Warning The Init method should not invoke any methods from other services yet, because it is not guaranteed that those services have had their Init methods invoked yet. It is safe to reference other services, but not to invoke their methods.","title":"service:Init()"},{"location":"services/#servicestart","text":"The Start method is called after all services have been initialized (i.e. their Init methods have been fully executed). Each Start method is executed on a separate thread (asynchronously). From here, it is safe to reference and invoke other services in the framework.","title":"service:Start()"},{"location":"services/#custom-methods","text":"Adding your own methods to a service is very easy. Simply attach a function to the service table: 1 2 3 4 5 6 7 8 9 -- Custom method: function MyService : PrintSomething (...) print ( \"MyService:\" , ...) end function MyService : Start () -- Invoke the custom method: self : PrintSomething ( \"Hi\" , \"Hello\" , 32 , true , \"ABC\" ) end Other services can also invoke your custom method: 1 2 3 function AnotherService : Start () self . Services . MyService : PrintSomething ( \"Hello\" , false , 64 ) end","title":"Custom Methods"},{"location":"services/#server-events","text":"You can create and listen to events using the RegisterEvent , ConnectEvent , and FireEvent methods. All events should always be registered within the Init method. The ConnectEvent and FireEvent methods should never be used within an Init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 function MyService : Start () -- Connect to 'Hello' event: self : ConnectEvent ( \"Hello\" , function ( msg ) print ( msg ) end ) -- Fire 'Hello' event: self : FireEvent ( \"Hello\" , \"Hello world!\" ) end function MyService : Init () -- Register 'Hello' event: self : RegisterEvent ( \"Hello\" ) end","title":"Server Events"},{"location":"services/#wrapmodule","text":"The WrapModule method can be used to transform a table into a framework-like module. In other words, it sets the table's metatable to the same metatable used by other framework modules, thus exposing the framework to the given table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function MyService : Start () local thisThing = {} function thisThing : Start () print ( \"thisThing started\" ) end function thisThing : Init () print ( \"thisThing initialized\" ) end -- Transform 'thisThing' into a framework object: self : WrapModule ( thisThing ) end This can be useful if you are requiring other non-framework modules in which you want to expose the framework.","title":"WrapModule"},{"location":"services/#client-table","text":"The Client table is used to expose methods and events to the client.","title":"Client Table"},{"location":"services/#client-methods","text":"To expose a method to the client, write a function attached to the client table: 1 2 3 function MyService . Client : Echo ( player , message ) return message end Attention The player argument must always be the first argument for client methods. Any other arguments reflect what the client has sent.","title":"Client Methods"},{"location":"services/#client-events","text":"To expose an event to the client, use the RegisterClientEvent method in the Init method. Use FireClientEvent and FireAllClientsEvent to fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 function MyService : Start () -- Fire client event for a specific player: self : FireClientEvent ( \"MyClientEvent\" , somePlayer , \"Hello\" ) -- Fire client event for all players: self : FireAllClientsEvent ( \"MyClientEvent\" , \"Hello\" ) end function MyService : Init () -- Register client event: self : RegisterClientEvent ( \"MyClientMethod\" ) end","title":"Client Events"},{"location":"services/#reference-server-table","text":"When executing code with a client-exposed method, it is useful to be able to reference back to the main service table. Therefore, the Server property has been injected into the Client table: 1 2 3 4 5 6 7 8 9 -- Client-exposed 'Echo' method invoking 'Print' method: function MyService . Client : Echo ( player , message ) self . Server : Print ( message ) -- Note the reference to 'self.Server' return message end function MyService : Print ( msg ) return msg end","title":"Reference Server Table"},{"location":"services/#other-examples","text":"","title":"Other Examples"},{"location":"services/#invoking-another-service","text":"1 2 3 4 5 function MyService : Start () -- Get some global data from the DataService: local dataService = self . Services . DataService local data = dataService : GetGlobal ( \"Test\" ) end","title":"Invoking another service"},{"location":"services/#using-a-module","text":"1 2 3 4 function MyService : Start () local someModule = self . Modules . SomeModule someModule : DoSomething () end","title":"Using a Module"},{"location":"services/#using-a-shared-module","text":"1 2 3 4 5 6 function MyService : Start () -- Print the current date: local Date = self . Shared . Date local now = Date . new () print ( \"Now\" , now ) end","title":"Using a Shared module"}]}